local function DarvkKey()
    local supportedKeys = {
        "AdminTest0",
        "validKey2",
        "validKey3",
        "441ddasd224999ammdm22",
        "AustonJK0",
        "Meatbed4444"
    }
    
    -- This variable stores the key, hidden from global access
    local userKey = nil

    -- Function to set the key
    local function setKey(key)
        userKey = key
    end

    -- Function to check if the key is valid
    local function isKeyValid()
        if not userKey then
            return false
        end
        for _, validKey in ipairs(supportedKeys) do
            if userKey == validKey then
                return true
            end
        end
        return false
    end

    return setKey, isKeyValid
end

-- Call hiddenKeyValidation() deep in your script
local setKey, isKeyValid = DarvkKey()

-- Set the key in some obscure way that isn't at the top of the script
setKey(getgenv().DarvkKey)

-- Validate the key before continuing
if not isKeyValid() then
    game.StarterGui:SetCore("SendNotification", {
        Title = "",
        Text = "",
        Duration = 10  
    })
    return -- Stop script execution if the key is invalid
end

local function getUserIdFromUsername(username)
    local success, userId = pcall(function()
        return game.Players:GetUserIdFromNameAsync(username)
    end)
    
    if success then
        return userId
    else
        warn("Failed to get user ID for username: " .. username)
        return nil
    end
end

-- Reference sizes for standard Roblox characters
local REFERENCE_SIZES = {
    Head = Vector3.new(2, 1, 1),
    Torso = Vector3.new(2, 2, 1),
    LeftArm = Vector3.new(1, 2, 1),
    RightArm = Vector3.new(1, 2, 1),
    LeftLeg = Vector3.new(1, 2, 1),
    RightLeg = Vector3.new(1, 2, 1)
}

-- Store original attachment positions to maintain proper offsets
local originalAttachmentPositions = {}

-- Determine accessory category based on its attachments
local function getAccessoryCategory(accessory)
    local handle = accessory:FindFirstChild("Handle")
    if not handle then return "Generic" end
    
    -- Store original attachment positions if not already stored
    if not originalAttachmentPositions[accessory] then
        originalAttachmentPositions[accessory] = {}
        for _, attachment in pairs(handle:GetChildren()) do
            if attachment:IsA("Attachment") then
                originalAttachmentPositions[accessory][attachment] = attachment.Position
            end
        end
    end
    
    -- Check for standard Roblox attachment points
    for _, attachment in pairs(handle:GetChildren()) do
        if attachment:IsA("Attachment") then
            local attachmentName = attachment.Name:lower()
            
            if attachmentName:find("hat") or attachmentName:find("head") then
                return "Hat"
            elseif attachmentName:find("hair") then
                return "Hair"
            elseif attachmentName:find("face") then
                return "Face"
            elseif attachmentName:find("neck") then
                return "Neck"
            elseif attachmentName:find("shoulder") then
                return "Shoulder"
            elseif attachmentName:find("front") then
                return "Front"
            elseif attachmentName:find("back") then
                return "Back"
            elseif attachmentName:find("waist") then
                return "Waist"
            elseif attachmentName:find("leftshoe") then
                return "LeftShoe"
            elseif attachmentName:find("rightshoe") then
                return "RightShoe"
            elseif attachmentName:find("leftarm") then
                return "LeftArm"
            elseif attachmentName:find("rightarm") then
                return "RightArm"
            elseif attachmentName:find("leftleg") then
                return "LeftLeg"
            elseif attachmentName:find("rightleg") then
                return "RightLeg"
            end
        end
    end
    
    return "Generic"
end

-- Calculate the scale factor based on character proportions and accessory category
local function getScaleFactor(character, category)
    if not getgenv().autoScale then 
        return getgenv().scaleMultiplier * (getgenv().accessoryCategories[category] or 1.0)
    end
    
    local head = character:FindFirstChild("Head")
    local torso = character:FindFirstChild(character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")
    
    if not head or not torso then 
        return getgenv().scaleMultiplier * (getgenv().accessoryCategories[category] or 1.0)
    end
    
    -- Calculate base scale based on head and torso size
    local headScale = head.Size.Y / REFERENCE_SIZES.Head.Y
    local torsoScale = torso.Size.Y / REFERENCE_SIZES.Torso.Y
    local averageScale = (headScale + torsoScale) / 2
    
    -- Apply category specific scaling
    return averageScale * getgenv().scaleMultiplier * (getgenv().accessoryCategories[category] or 1.0)
end

-- Scale an accessory while maintaining proper positioning
local function scaleAccessory(accessory, character)
    local category = getAccessoryCategory(accessory)
    local scaleFactor = getScaleFactor(character, category)
    local handle = accessory:FindFirstChild("Handle")
    
    if handle then
        -- Scale all parts in the accessory
        for _, part in pairs(accessory:GetDescendants()) do
            if part:IsA("BasePart") then
                -- Store original size if not already stored
                if not originalAttachmentPositions[accessory].originalSizes then
                    originalAttachmentPositions[accessory].originalSizes = {}
                end
                if not originalAttachmentPositions[accessory].originalSizes[part] then
                    originalAttachmentPositions[accessory].originalSizes[part] = part.Size
                end
                
                -- Apply scaling from original size
                part.Size = originalAttachmentPositions[accessory].originalSizes[part] * scaleFactor
                
                -- Scale any meshes
                local mesh = part:FindFirstChildOfClass("SpecialMesh") or part:FindFirstChildOfClass("Mesh")
                if mesh then
                    if not originalAttachmentPositions[accessory].originalMeshScales then
                        originalAttachmentPositions[accessory].originalMeshScales = {}
                    end
                    if not originalAttachmentPositions[accessory].originalMeshScales[mesh] then
                        originalAttachmentPositions[accessory].originalMeshScales[mesh] = mesh.Scale
                    end
                    mesh.Scale = originalAttachmentPositions[accessory].originalMeshScales[mesh] * scaleFactor
                end
                
                -- Scale attachments from their original positions
                for _, attachment in pairs(part:GetChildren()) do
                    if attachment:IsA("Attachment") and originalAttachmentPositions[accessory][attachment] then
                        attachment.Position = originalAttachmentPositions[accessory][attachment] * scaleFactor
                    end
                end
            end
        end
    end
end

-- Function to set scale for a specific accessory category
local function setCategoryScale(category, scale)
    if getgenv().accessoryCategories[category] then
        getgenv().accessoryCategories[category] = scale
        -- Reapply scaling to all accessories
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, accessory in pairs(character:GetChildren()) do
                if accessory:IsA("Accessory") then
                    scaleAccessory(accessory, character)
                end
            end
        end
    end
end

-- Function to weld parts together
local function weldParts(part0, part1, c0, c1)
    local weld = Instance.new("Weld")
    weld.Part0 = part0
    weld.Part1 = part1
    weld.C0 = c0
    weld.C1 = c1
    weld.Parent = part0
    return weld
end

-- Function to set accessory collision and anchored properties
local function disableCollisionsForAccessory(accessory, isShoe)
    for _, part in pairs(accessory:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("UnionOperation") then
            if isShoe then
                part.CanCollide = getgenv().shoeCollision  -- Use shoeCollision for shoes
            else
                part.CanCollide = getgenv().accessoryCollision  -- Use accessoryCollision for other accessories
            end
            part.Anchored = getgenv().anchored
        end
    end
end

-- Function to add shoe to character (specific to shoes, not regular accessories)
local function addShoeToCharacter(shoeId, footPart)
    local shoe = game:GetObjects("rbxassetid://" .. tostring(shoeId))[1]
    local character = game.Players.LocalPlayer.Character

    shoe.Parent = game.Workspace  -- Place the shoe temporarily in the workspace

    -- Use shoeCollision specifically for shoes
    disableCollisionsForAccessory(shoe, true)

    -- Apply scaling before adding to character
    scaleAccessory(shoe, character)

    -- Find the "Handle" or root part of the shoe
    local handle = shoe:FindFirstChild("Handle")
    if handle then
        -- Weld the shoe to the appropriate foot (LeftFoot or RightFoot)
        weldParts(footPart, handle, CFrame.new(0, 0, 0), CFrame.new(0, 0, 0))  -- Adjust the position if needed
    else
        -- Handle case where the shoe doesn't have a "Handle" part
        local shoePart = shoe.PrimaryPart or shoe:FindFirstChildWhichIsA("Part")
        if shoePart then
            weldParts(footPart, shoePart, CFrame.new(0, 0, 0), CFrame.new(0, 0, 0))  -- Adjust the position if needed
        end
    end

    shoe.Parent = character  -- Parent the shoe to the character after welding
end

-- Function to find attachment by name
local function findAttachment(rootPart, name)
    for _, descendant in pairs(rootPart:GetDescendants()) do
        if descendant:IsA("Attachment") and descendant.Name == name then
            return descendant
        end
    end
end

-- Updated removeCurrentCharacter function
local function removeCurrentCharacter(player)
    if not player or not player.Character then return end
    
    -- Only remove items if removeAllItems is true
    if not getgenv().removeAllItems then return end

    for _, v in pairs(player.Character:GetChildren()) do
        if v:IsA("Accessory") or v:IsA("Shirt") or v:IsA("Pants") or v:IsA("CharacterMesh") or v:IsA("BodyColors") then
            v:Destroy()
        end
    end
    
    -- Only remove face if removeAllItems is true AND we're not keeping the original face
    if player.Character:FindFirstChild("Head") and getgenv().removeAllItems then
        local head = player.Character.Head
        if head:FindFirstChild("face") and not getgenv().keepOriginalFace then
            head.face:Destroy()
        end
    end
end

local function applyAppearance(player, appearance, headless, showfacewhenheadless)
    if not player or not player.Character then return end
    
    -- Automatically set headless behavior based on the global Headless setting
    if getgenv().Headless then
        headless = true
    end

    -- Apply the appearance to the player
    for _, v in pairs(appearance:GetChildren()) do
        if v:IsA("Shirt") or v:IsA("Pants") or v:IsA("BodyColors") then
            v.Parent = player.Character
        elseif v:IsA("Accessory") then
            if getgenv().showHats then  -- Check if hats should be shown
                player.Character.Humanoid:AddAccessory(v)
                scaleAccessory(v, player.Character)
            end
        elseif v.Name == "R6" then
            if player.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
                v:FindFirstChildOfClass("CharacterMesh").Parent = player.Character
            end
        elseif v.Name == "R15" then
            if player.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
                v:FindFirstChildOfClass("CharacterMesh").Parent = player.Character
            end
        end
    end

    -- Skip face modifications if we're keeping the original face
    if getgenv().keepOriginalFace then
        return
    end

    -- Handle headless logic (only runs if not keeping original face)
    if headless then
        -- If headless, make sure the face is hidden unless showFaceWhenHeadless is true
        if not showfacewhenheadless then
            if player.Character.Head:FindFirstChild("face") then
                player.Character.Head.face:Destroy()
            end
        else
            -- Show the face when headless is enabled and showFaceWhenHeadless is true
            local face = Instance.new("Decal")
            face.Face = Enum.NormalId.Front
            face.Name = "face"
            face.Texture = "rbxasset://textures/face.png"
            face.Transparency = 0
            face.Parent = player.Character.Head
        end
    else
        -- Only apply the appearance face if we're not keeping the original
        if appearance:FindFirstChild("face") and not getgenv().keepOriginalFace then
            appearance.face.Parent = player.Character.Head
        elseif not player.Character.Head:FindFirstChild("face") then
            -- Fallback to default face if no face exists
            local face = Instance.new("Decal")
            face.Face = Enum.NormalId.Front
            face.Name = "face"
            face.Texture = "rbxasset://textures/face.png"
            face.Transparency = 0
            face.Parent = player.Character.Head
        end
    end
end

-- Function to toggle head visibility based on Headless setting
local function toggleHeadVisibility(character)
    if character and character:FindFirstChild("Head") then
        local head = character.Head

        if getgenv().Headless then
            -- Hide the face and make the head transparent when headless is enabled
            head.Transparency = 1
            if head:FindFirstChild("face") then
                head.face:Destroy()
            end
        else
            -- Show the head and apply the face based on the toggle
            head.Transparency = 0
            if not head:FindFirstChild("face") then
                -- Recreate the face if it doesn't exist
                local face = Instance.new("Decal")
                face.Name = "face"
                face.Texture = "rbxassetid://" .. getgenv().FaceID -- Replace with the actual face ID
                face.Parent = head
            end
        end
    end
end

-- Function to morph into another player's appearance based on UserID
local function Morph(username, headless, showfacewhenheadless)
    local userId = getUserIdFromUsername(username)
    if not userId then return end

    local appearance = game.Players:GetCharacterAppearanceAsync(userId)
    local player = game.Players.LocalPlayer

    -- Only clear if removeAllItems is true
    if getgenv().removeAllItems then
        removeCurrentCharacter(player)
    end

    applyAppearance(player, appearance, headless, showfacewhenheadless)

    -- Reload character (optional, can remove if causing issues)
    local parent = player.Character.Parent
    player.Character.Parent = nil
    player.Character.Parent = parent
end

-- Add accessory to character (non-shoes)
local function addAccessoryToCharacter(accessoryId, parentPart)
    local character = game.Players.LocalPlayer.Character
    if not character then return end

    -- Check if the accessory is already present
    local existingAccessory = character:FindFirstChild(accessoryId)
    if existingAccessory then
        return -- Exit if the accessory is already added
    end

    local accessory = game:GetObjects("rbxassetid://" .. tostring(accessoryId))[1]
    accessory.Parent = game.Workspace

    -- Set CanCollide based on the toggle (using canCollide for non-shoes)
    disableCollisionsForAccessory(accessory, false)

    -- Apply scaling before adding to character
    scaleAccessory(accessory, character)

    local handle = accessory:FindFirstChild("Handle")
    if handle then
        local attachment = handle:FindFirstChildOfClass("Attachment")
        if attachment then
            local parentAttachment = findAttachment(parentPart, attachment.Name)
            if parentAttachment then
                -- Adjust the CFrame to prevent collisions
                weldParts(parentPart, handle, parentAttachment.CFrame * CFrame.new(0, 0.1, 0), attachment.CFrame)
            end
        else
            local parent = character:FindFirstChild(parentPart.Name)
            if parent then
                local attachmentPoint = accessory.AttachmentPoint
                -- Adjust the CFrame to prevent collisions
                weldParts(parent, handle, CFrame.new(0, 0.5, 0), attachmentPoint.CFrame)
            end
        end

        -- Collect sounds in the accessory
        local soundList = {}
        for _, sound in pairs(handle:GetDescendants()) do
            if sound:IsA("Sound") then
                table.insert(soundList, sound)
            end
        end

        -- Shuffle the sound list
        local function shuffle(t)
            for i = #t, 2, -1 do
                local j = math.random(i)
                t[i], t[j] = t[j], t[i]
            end
        end

        shuffle(soundList)

        -- Function to play sounds asynchronously
        local function playSounds()
            local delays = {1.5, 5, 8} -- Possible delays
            local playCount = 0 -- Counter to limit the number of plays
            local maxPlays = 10 -- Set a maximum number of times to play sounds

            while playCount < maxPlays do -- Loop until maxPlays is reached
                for _, sound in ipairs(soundList) do
                    if sound and sound:IsA("Sound") then
                        -- Clone the sound to avoid interrupting the original
                        local soundClone = sound:Clone()
                        soundClone.Parent = handle -- Parent the clone to the handle
                        soundClone:Play() -- Play the cloned sound

                        -- Wait for the sound to finish playing
                        task.wait(soundClone.TimeLength) -- Wait for the sound to finish
                        -- Add a delay after each sound
                        local randomDelay = delays[math.random(1, #delays)]
                        task.wait(randomDelay) -- Wait for a random delay before the next sound
                    end
                end
                playCount = playCount + 1 -- Increment the play count
            end
        end

        -- Start the sound playback in a coroutine
        coroutine.wrap(playSounds)()
    end

    accessory.Parent = character
end

-- Updated applyFace function
local function applyFace(faceId)
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local head = character:FindFirstChild("Head")
    if not head then return end

    -- Don't modify face if keeping original and it exists
    if getgenv().keepOriginalFace and head:FindFirstChild("face") then
        return
    end

    -- Only proceed if showFace is true
    if getgenv().showFace then
        -- Remove existing face if it exists
        local existingFace = head:FindFirstChild("face")
        if existingFace then
            existingFace:Destroy()
        end
        
        -- Apply new face
        local face = Instance.new("Decal")
        face.Name = "face"
        face.Texture = "rbxassetid://"..faceId
        face.Face = Enum.NormalId.Front
        face.Parent = head
    elseif head:FindFirstChild("face") then
        head.face:Destroy()
    end
end

-- Function to check if an item is blacklisted for R6
local function isBlacklistedForR6(itemId)
    for _, blacklistedId in ipairs(getgenv().R6Blacklist) do
        if tostring(itemId) == tostring(blacklistedId) then
            return true
        end
    end
    return false
end

local function loadAccessories(character)
    if not character then return end
    
    -- Always apply the player's face first
    applyFace(getgenv().FaceID)

    -- Check if the character is using R6 or R15
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        warn("Humanoid not found in character.")
        return
    end

    local isR6 = humanoid.RigType == Enum.HumanoidRigType.R6

    if getgenv().loadingMode == "OutfitLoader" then
        -- Load only the player outfit (hat visibility handled in applyAppearance)
        Morph(getgenv().targetPlayerUsername)
    elseif getgenv().loadingMode == "ItemsLoader" then
        -- Load individual items with hat toggle
        if getgenv().showHats then
            for _, accessoryId in ipairs(getgenv().Head) do
                if not (isR6 and isBlacklistedForR6(accessoryId)) then
                    addAccessoryToCharacter(accessoryId, character:FindFirstChild("Head"))
                end
            end
        end

        for _, accessoryId in ipairs(getgenv().Shoulder) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.UpperTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end
        
        -- Torso accessories (always shown)
        for _, accessoryId in ipairs(getgenv().Torso) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.UpperTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end

        -- Waist accessories (always shown)
        for _, accessoryId in ipairs(getgenv().Waist) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.LowerTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end

        -- Shoes (always shown)
        for _, shoeId in ipairs(getgenv().Shoes) do
            local rightFoot = character:FindFirstChild("RightFoot")
            local leftFoot = character:FindFirstChild("LeftFoot")
            if rightFoot then addShoeToCharacter(shoeId, rightFoot) end
            if leftFoot then addShoeToCharacter(shoeId, leftFoot) end
        end

    elseif getgenv().loadingMode == "CombineBoth" then
        -- Combine outfit and items with hat toggle
        Morph(getgenv().targetPlayerUsername)
        
        -- THEN add accessories (skip face application)
        if getgenv().showHats then
            for _, accessoryId in ipairs(getgenv().Head) do
                if not (isR6 and isBlacklistedForR6(accessoryId)) then
                    addAccessoryToCharacter(accessoryId, character:FindFirstChild("Head"))
                end
            end
        end

        for _, accessoryId in ipairs(getgenv().Shoulder) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.UpperTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end

        -- Additional accessories (always shown)
        for _, accessoryId in ipairs(getgenv().Torso) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.UpperTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end

        for _, accessoryId in ipairs(getgenv().Waist) do
            if not (isR6 and isBlacklistedForR6(accessoryId)) then
                local parentPart = isR6 and character.Torso or character.LowerTorso
                addAccessoryToCharacter(accessoryId, parentPart)
            end
        end

        for _, shoeId in ipairs(getgenv().Shoes) do
            local rightFoot = character:FindFirstChild("RightFoot")
            local leftFoot = character:FindFirstChild("LeftFoot")
            if rightFoot then addShoeToCharacter(shoeId, rightFoot) end
            if leftFoot then addShoeToCharacter(shoeId, leftFoot) end
        end
    end

    -- Final head visibility check
    toggleHeadVisibility(character)
end

-- Function to handle character added event
local function onCharacterAdded(character)
    wait(getgenv().Time)
    
    if getgenv().removeAllItems or not getgenv().combineAccessories then
        removeCurrentCharacter(game.Players.LocalPlayer)
    end
    
    loadAccessories(character)
end

-- Connect the character added event to the function
game.Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Initial call to load accessories for the current character
if game.Players.LocalPlayer.Character then
    onCharacterAdded(game.Players.LocalPlayer.Character)
end

-- Variable to control the auto-reload loop
local autoReloadRunning = false

-- Function to manage auto-reload
local function manageAutoReload()
    while true do
        wait(getgenv().autoReloadWaitTime) -- Use the configurable wait time
        if getgenv().autoReload then
            if game.Players.LocalPlayer.Character then
                onCharacterAdded(game.Players.LocalPlayer.Character)
            end
        else
            -- If auto-reload is disabled, break the loop
            break
        end
    end
end

-- Start the auto-reload management if enabled
if getgenv().autoReload then
    autoReloadRunning = true
    manageAutoReload()
end

-- User Input Service for key press detection
local UserInputService = game:GetService("UserInputService")

-- Function to refresh the character's appearance
local function refreshAppearance()
    if getgenv().enableRefresh and game.Players.LocalPlayer.Character then
        onCharacterAdded(game.Players.LocalPlayer.Character)
    end
end

-- Function to handle key press events
local function onInputBegan(input, gameProcessedEvent)
    if not gameProcessedEvent then
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().refreshKeybind then
            refreshAppearance()
        end
    end
end

-- Connect the input began event to the function
UserInputService.InputBegan:Connect(onInputBegan)
